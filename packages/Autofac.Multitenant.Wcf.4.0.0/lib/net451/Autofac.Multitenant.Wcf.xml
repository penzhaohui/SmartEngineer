<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Autofac.Multitenant.Wcf</name>
    </assembly>
    <members>
        <member name="T:Autofac.Multitenant.Wcf.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.ArgumentException_StringEmpty">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; may not be empty..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.AutofacHostFactory_ContainerIsNull">
            <summary>
              Looks up a localized string similar to The AutofacHostFactory.Container static property must be set before services can be instantiated..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.AutofacHostFactory_NoServiceHostType">
            <summary>
              Looks up a localized string similar to No type to host was provided by the &apos;{0}&apos; for the service &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.AutofacHostFactory_ServiceHostTypeNotClass">
            <summary>
              Looks up a localized string similar to The &apos;{0}&apos; did not provide a type to be hosted by WCF that was a concrete implementation type. WCF requires a service host to host a class, not an interface. Consider using a reflection-based registration or an expression-based registration where the return value is a class type. The current service type being returned by &apos;{0}&apos; for constructor string &apos;{1}&apos; is &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.AutofacHostFactory_ServiceNotRegistered">
            <summary>
              Looks up a localized string similar to The service &apos;{0}&apos; configured for WCF is not registered with the Autofac container..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.DynamicProxy_InterfaceTypeToProxyIsGeneric">
            <summary>
              Looks up a localized string similar to Interface type &apos;{0}&apos; is a generic type definition. You may not create WCF dynamic proxies from open generic interfaces..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.DynamicProxy_InterfaceTypeToProxyNotInterface">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; cannot be turned into a proxy type for WCF hosting because it is not an interface. Multitenant WCF hosting requires you to implement a separate interface for your service contract..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.DynamicProxy_InterfaceTypeToProxyNotPublic">
            <summary>
              Looks up a localized string similar to Interface type &apos;{0}&apos; is not public. It must be accessible so a dynamic proxy object can be created from it..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.DynamicProxy_InterfaceTypeToProxyNotServiceContract">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; cannot be turned into a proxy type for WCF hosting because it is not marked with System.ServiceModel.ServiceContractAttribute. Multitenant WCF hosting requires you to implement a separate interface for your service contract..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.DynamicProxy_ProxyTargetDoesNotImplementInterface">
            <summary>
              Looks up a localized string similar to The service implementation to proxy, type &apos;{0}&apos;, does not implement the service interface &apos;{1}&apos; that the proxy will implement. Check your Autofac registrations to make sure the service implementation type isn&apos;t somehow tied to the service interface..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.MultitenantServiceImplementationDataProvider_ServiceInterfaceTypeNotInterface">
            <summary>
              Looks up a localized string similar to The string &apos;{0}&apos; resolved to type &apos;{1}&apos; which is not an interface. For multitenancy to work, the service type to host should be the service interface rather than the concrete implementation type. You then register the concrete implementation type as the interface with Autofac, like: builder.RegisterType&lt;ImplementationType&gt;().As&lt;InterfaceType&gt;();.
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.MultitenantServiceImplementationDataProvider_ServiceInterfaceTypeNotResolvable">
            <summary>
              Looks up a localized string similar to The string &apos;{0}&apos; could not be resolved to a type. Make sure you specify the fully qualified type name, like &quot;Namespace.TypeName, AssemblyName&quot; and not just the type name..
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.Properties.Resources.MultitenantServiceImplementationDataProvider_ServiceInterfaceTypeNotServiceContract">
            <summary>
              Looks up a localized string similar to The string &apos;{0}&apos; resolved to type &apos;{1}&apos; which is not marked with the System.ServiceModel.ServiceContractAttribute. For multitenancy to work, the service type to host should be the service contract interface. You then register the concrete implementation type as the interface with Autofac, like: builder.RegisterType&lt;ImplementationType&gt;().As&lt;InterfaceType&gt;();.
            </summary>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.CustomAttributeDataExtensions">
            <summary>
            Extension methods for <see cref="T:System.Reflection.CustomAttributeData"/>.
            </summary>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.CustomAttributeDataExtensions.ToAttributeBuilder(System.Reflection.CustomAttributeData)">
            <summary>
            Converts a custom attribute data object to a custom attribute builder for code generation.
            </summary>
            <param name="data">The data about a custom attribute to be converted for code emission.</param>
            <returns>
            A <see cref="T:System.Reflection.Emit.CustomAttributeBuilder"/> with
            the same values as <paramref name="data" /> so it can be copied
            to another member in code generation.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="data" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor">
            <summary>
            Code generator that ignores type-level non-inherited attributes.
            </summary>
            <remarks>
            <para>
            The default behavior of <see cref="T:Castle.DynamicProxy.Contributors.InterfaceProxyInstanceContributor"/>
            is to generate a type definition that copies over all of the non-inherited
            attributes from the target interface. This includes the <see cref="T:System.ServiceModel.ServiceContractAttribute"/>
            that would be copied over from service interfaces. Unfortunately, WCF
            doesn't allow a type marked with <see cref="T:System.ServiceModel.ServiceContractAttribute"/>
            to also implement an interface marked with <see cref="T:System.ServiceModel.ServiceContractAttribute"/>.
            This code generator does everything that <see cref="T:Castle.DynamicProxy.Contributors.InterfaceProxyInstanceContributor"/>
            does except it doesn't copy over type-level non-inherited attributes.
            </para>
            </remarks>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor"/> class.
            </summary>
            <param name="targetType">Type of the target to proxy.</param>
            <param name="proxyGeneratorId">The proxy generator ID.</param>
            <param name="interfaces">The additional interfaces to implement.</param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor.Generate(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
            Generates the class defined by the provided class emitter.
            </summary>
            <param name="class">
            The <see cref="T:Castle.DynamicProxy.Generators.Emitters.ClassEmitter"/>
            being used to build the target type.
            </param>
            <param name="options">The options to use during proxy generation.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="class" /> is <see langword="null" />.
            </exception>
            <remarks>
            <para>
            This overridden version of the method does everything that the base
            <see cref="M:Castle.DynamicProxy.Contributors.ProxyInstanceContributor.Generate(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,Castle.DynamicProxy.ProxyGenerationOptions)"/>
            method does but it skips the part where it checks for non-inherited
            attributes and copies them over from the proxy target.
            </para>
            </remarks>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator">
            <summary>
            Interface proxy generator that builds a proxy that has a default constructor
            and does not copy over non-inherited type attributes.
            </summary>
            <remarks>
            <para>
            The standard <see cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator"/>
            builds a proxy object that has no default constructor. While a default
            constructor is not useful from an actual proxying standpoint, the WCF
            service host will only host object types that have default constructors.
            As such, if we want to start the service host with a proxy type, the
            proxy type has to have a default constructor.
            </para>
            <para>
            Also, the standard <see cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator"/>
            generates a type that copies all of the non-inherited attributes over
            from the target interface, which causes WCF to choke on the
            <see cref="T:System.ServiceModel.ServiceContractAttribute"/>, which is
            already on the service contract interface. This generator overrides
            <see cref="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator.GetTypeImplementerMapping(System.Type[],System.Type,System.Collections.Generic.IEnumerable{Castle.DynamicProxy.Contributors.ITypeContributor}@,Castle.DynamicProxy.Generators.INamingScope)"/>
            to change the set of code generating contributors to make a slimmer
            proxy that WCF hosting will accept.
            </para>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor"/>
        </member>
        <member name="F:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator._metadataBuddyType">
            <summary>
            Holds the metadata buddy class type for the service interface.
            </summary>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator.#ctor(Castle.DynamicProxy.ModuleScope,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator"/> class.
            </summary>
            <param name="scope">The scope of the module being built.</param>
            <param name="interface">The interface that will be proxied.</param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator.CreateTypeAttributes(Castle.DynamicProxy.Generators.Emitters.ClassEmitter)">
            <summary>
            Adds custom attributes to the generated type.
            </summary>
            <param name="emitter">The class emitter.</param>
            <remarks>
            <para>
            This override calls the base functionality and then uses the metadata
            buddy class (as specified by a <see cref="T:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute"/>
            on the service interface) to copy over class-level attributes to the
            dynamic hosting proxy.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="emitter" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator.GetTypeImplementerMapping(System.Type[],System.Type,System.Collections.Generic.IEnumerable{Castle.DynamicProxy.Contributors.ITypeContributor}@,Castle.DynamicProxy.Generators.INamingScope)">
            <summary>
            Gets the contributors for generating the type definition.
            </summary>
            <param name="interfaces">Additional interfaces to implement.</param>
            <param name="proxyTargetType">The target type for the proxy.</param>
            <param name="contributors">The list of contributors that will be used to generate the type.</param>
            <param name="namingScope">The proxy type naming scope.</param>
            <returns>
            The list of types being implemented.
            </returns>
            <remarks>
            <para>
            This version of the method basically does the same thing as the
            original/base implementation but with these key differences:
            </para>
            <list type="bullet">
            <item>
            <term>No mixin support</term>
            <description>
            The original version of the method looks at the <see cref="P:Castle.DynamicProxy.Generators.BaseProxyGenerator.ProxyGenerationOptions"/>
            to see if there are any mixins to be added to the generated proxy.
            There is no need for mixin support in WCF service hosting so mixins
            aren't even checked for and won't be added.
            </description>
            </item>
            <item>
            <term>No additional interfaces</term>
            <description>
            The original version of the method goes through each of the additional
            interfaces that the are to be implemented, checks them against collisions
            with mixin definitions, and adds type mappings for the additional interfaces.
            The only interface that needs to be implemented for the WCF hosting
            proxy is the service interface, so all of that additional interface
            checking is skipped.
            </description>
            </item>
            <item>
            <term>Custom instance contributor used</term>
            <description>
            The original version of the method uses the
            <see cref="T:Castle.DynamicProxy.Contributors.InterfaceProxyInstanceContributor"/>
            as the code generator for the proxy type. Unfortunately, that contributor
            copies over all non-inherited attributes on the interface including
            the <see cref="T:System.ServiceModel.ServiceContractAttribute"/>. The
            concrete proxy type can't have that attribute because the interface
            already has it, so WCF hosting dies. This version of the method uses
            the <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor"/>
            which does not copy over non-inherited attributes.
            </description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.DynamicProxy.IgnoreAttributeInterfaceProxyInstanceContributor"/>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder">
            <summary>
            Proxy builder that has an additional method to create proxies usable
            in WCF multitenant hosting.
            </summary>
            <remarks>
            <para>
            The primary point of interest in this builder type is the
            <see cref="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder.CreateWcfProxyType(System.Type)"/>
            method, which is used to create an interface proxy type that is hostable
            by WCF.
            </para>
            </remarks>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder.AssertValidType(System.Type)">
            <summary>
            Validates that the target type to proxy is visible and not generic.
            </summary>
            <param name="target">
            The interface type to proxy.
            </param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder.CreateWcfProxyType(System.Type)">
            <summary>
            Creates an interface proxy type that can be used by the WCF host.
            </summary>
            <param name="interfaceToProxy">The service interface to proxy.</param>
            <returns>
            A <see cref="T:System.Type"/> that is a proxy for the interface specified
            by <paramref name="interfaceToProxy" /> that will be able to be
            hosted by WCF.
            </returns>
            <remarks>
            <para>
            This proxy type creation method uses the
            <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator"/>
            to create the service host proxy type. As this is a very specialized
            proxy type, it does not take options like other proxy types.
            </para>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostInterfaceProxyGenerator" />
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator">
            <summary>
            Proxy generator used in multitenant service hosting.
            </summary>
            <remarks>
            <para>
            The WCF service host has very specific requirements around the object type that
            you pass in when you call <see cref="M:System.ServiceModel.Activation.ServiceHostFactory.CreateServiceHost(System.Type,System.Uri[])"/>.
            </para>
            <para>
            If you have a type that has a <see cref="T:System.ServiceModel.ServiceContractAttribute"/>
            on it and it implements an interface that has <see cref="T:System.ServiceModel.ServiceContractAttribute"/>
            on it, the WCF service host complains that you can't have two different
            service contracts.
            </para>
            <para>
            The proxy generator uses a <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder"/>
            to build the proxy types. This is specifically interesting in the
            <see cref="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator.CreateWcfProxy(System.Type,System.Object)"/>
            method, which uses some special overrides and additions in the builder.
            </para>
            <para>
            The builder, when called through
            <see cref="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator.CreateWcfProxy(System.Type,System.Object)"/>,
            generates proxy types that ignore non-inherited
            attributes on the service interface (e.g.,
            <see cref="T:System.ServiceModel.ServiceContractAttribute"/>)
            so when the proxy type is generated, it doesn't bring over anything
            that will cause WCF host initialization to fail or get confused.
            </para>
            </remarks>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator"/> class.
            </summary>
            <remarks>
            <para>
            The proxy generator uses a <see cref="T:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyBuilder"/>
            to build the proxy types.
            </para>
            </remarks>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator.CreateWcfProxy(System.Type,System.Object)">
            <summary>
            Creates a proxy object that can be used by the WCF service host.
            </summary>
            <param name="interfaceToProxy">
            The WCF service interface for service implementations.
            </param>
            <param name="target">
            The target of the proxy object that will receive the actual calls.
            </param>
            <returns>
            An object that implements the interface <paramref name="interfaceToProxy" />
            and proxies calls to the <paramref name="target" />.
            </returns>
            <remarks>
            <para>
            When initializing the service host, call this method with a dummy
            <paramref name="target" /> object, just to create the dynamic proxy
            type for the first time and get the service host up and running.
            Subsequent proxies for that interface should have a valid target
            implementation type to which service calls will be proxied.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="interfaceToProxy" /> or <paramref name="target" /> is <see langword="null" />.
            </exception>
            <exception cref="T:System.ArgumentException">
            <para>
            Thrown if:
            </para>
            <list type="bullet">
            <item>
            <term><paramref name="interfaceToProxy" /> is not an interface.</term>
            </item>
            <item>
            <term><paramref name="interfaceToProxy" /> is an open generic.</term>
            </item>
            <item>
            <term><paramref name="target" /> cannot be cast to <paramref name="interfaceToProxy" />.</term>
            </item>
            </list>
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.ServiceHostProxyGenerator.CreateWcfProxyType(System.Type)">
            <summary>
            Creates the WCF service interface proxy type or retrieves it from cache.
            </summary>
            <param name="interfaceToProxy">
            The interface type that will be proxied.
            </param>
            <returns>
            A generated proxy type that can be used to proxy calls to actual
            service implementations.
            </returns>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.DynamicProxy.TypeExtensions">
            <summary>
            Extension methods for the <see cref="T:System.Type"/> class.
            </summary>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.DynamicProxy.TypeExtensions.GetMetadataClassType(System.Type)">
            <summary>
            Gets the metadata buddy class type, if any, as marked by a
            <see cref="T:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute"/>
            </summary>
            <param name="interfaceType">The service interface type from which to retrieve the metadata class.</param>
            <returns>
            The metadata type for the service interface as specified by a
            <see cref="T:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute"/>,
            if it exists; otherwise <see langword="null" />.
            </returns>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.MultitenantServiceImplementationDataProvider">
            <summary>
            Service implementation data provider that returns multitenant-aware
            service hosting information.
            </summary>
        </member>
        <member name="F:Autofac.Multitenant.Wcf.MultitenantServiceImplementationDataProvider._generator">
            <summary>
            Proxy generator used to create proxy types that will be substituted
            in during service hosting.
            </summary>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.MultitenantServiceImplementationDataProvider.GetServiceImplementationData(System.String)">
            <summary>
            Gets data about a service implementation.
            </summary>
            <param name="value">
            The constructor string passed in to the service host factory
            that is used to determine which type to host/use as a service
            implementation.
            </param>
            <returns>
            A <see cref="T:Autofac.Integration.Wcf.ServiceImplementationData"/>
            object containing information about which type to use in
            the service host and how to resolve the implementation.
            </returns>
            <remarks>
            <para>
            This method returns a dynamic proxy object as the type to host
            and resolves the implementation type as a dynamic proxy that proxies
            to a tenant-specific implementation. This is necessary since
            WCF will only allow hosting of concrete classes and we need it to,
            effectively, host an 'interface' - in this case, a dynamic proxy type
            rather than an actual implementation type.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="value" /> is <see langword="null" />.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="value" /> is empty.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="value" /> does not resolve into
            a known type, resolves to a type that is not an interface, or the
            interface it resolves to is not marked with a <see cref="T:System.ServiceModel.ServiceContractAttribute"/>.
            </exception>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute">
            <summary>
            Specifies the metadata class to associate with a service implementation.
            </summary>
            <remarks>
            <para>
            When hosting a service in a multitenant environment using <see cref="T:Autofac.Integration.Wcf.AutofacHostFactory"/>
            and the dynamic proxy generation that occurs therein, you can't really
            mark your "service implementation class" with metadata attributes like
            the <see cref="T:System.ServiceModel.ServiceBehaviorAttribute"/>. Also,
            since many of these attributes require you to mark a class rather than
            the service interface, there's no way to otherwise specify them.
            </para>
            <para>
            This attribute works similar to the <c>System.ComponentModel.DataAnnotations.MetadataTypeAttribute</c>
            and allows you to mark a service interface such that the generated dynamic
            proxy class will use a "metadata buddy class" to retrieve various attributes
            that should be applied during generation.
            </para>
            <para>
            Mark your service interface with one of these attributes, then create an
            empty class with the <see cref="T:System.ServiceModel.ServiceBehaviorAttribute"/>
            (or whatever) associated with it. The dynamic proxy generation will copy
            these attributes, thus allowing you to still make use of service metadata info.
            </para>
            <para>
            This is particularly handy when choosing to specify a service name. Since
            WCF usually infers the service name (which is also the name of the service
            element in configuration that it uses to set up the service host) from the
            type of the implementation, a dynamic proxy implementation results in
            service names like <c>Castle.Proxies.IMyServiceProxy_1</c>. To manually
            specify the name, you use the <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.Name"/>
            property, which can be associated with a service metadata buddy class.
            </para>
            </remarks>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute.MetadataClassType">
            <summary>
            Gets the metadata class type.
            </summary>
            <value>
            A <see cref="T:System.Type"/> indicating the class to be used to
            gather metadata for the service implementation proxy.
            </value>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Autofac.Multitenant.Wcf.ServiceMetadataTypeAttribute"/> class.
            </summary>
            <param name="metadataClassType">The metadata class type for specifying service metadata.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="metadataClassType" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy">
            <summary>
            An <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>
            implementation that gets the tenant ID from a <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            attached to the current <see cref="T:System.ServiceModel.OperationContext"/>.
            </summary>
            <remarks>
            <para>
            Use this <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>
            if you are using the <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            as the mechanism for tracking which tenant a given operation is running
            under.
            </para>
            <para>
            For example, you could use an <see cref="T:System.ServiceModel.Dispatcher.IDispatchMessageInspector"/>
            that gets the tenant ID from an incoming header and adds a
            <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            to the current <see cref="T:System.ServiceModel.OperationContext"/> with
            the tenant ID value. Then you could register this provider as the
            mechanism for determining the tenant ID when resolving multitenant dependencies.
            </para>
            <para>
            The <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
            does exactly that - adds the tenant ID to outbound messages on the client
            and parses them on the service side. For a usage example, see
            <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
            </para>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            <seealso cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy.TryIdentifyTenant(System.Object@)">
            <summary>
            Attempts to identify the tenant from the current operation context.
            </summary>
            <param name="tenantId">The current tenant identifier.</param>
            <returns>
            <see langword="true"/> if the tenant could be identified; <see langword="false"/>
            if not.
            </returns>
            <remarks>
            <para>
            The <paramref name="tenantId" /> will be the <see cref="T:System.Object"/> value from the first
            <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            found on the current <see cref="T:System.ServiceModel.OperationContext"/>,
            or <see langword="null" /> if there is no extension found on the
            operation context.
            </para>
            </remarks>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension">
            <summary>
            Extension for <see cref="T:System.ServiceModel.OperationContext"/>
            that allows propagation of the tenant ID.
            </summary>
            <remarks>
            <para>
            Use this extension in conjunction with the
            <see cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
            to determine which tenant a given operation is running under.
            </para>
            <para>
            For example, you could use an <see cref="T:System.ServiceModel.Dispatcher.IDispatchMessageInspector"/>
            that gets the tenant ID from an incoming header and adds a
            <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            to the current <see cref="T:System.ServiceModel.OperationContext"/> with
            the tenant ID value. Then you could register the
            <see cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
            as the mechanism for determining the tenant ID when resolving multitenant dependencies.
            </para>
            <para>
            The <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
            is a behavior that does exactly that - adds the tenant ID to outbound messages on the client
            and parses them on the service side. For a usage example, see
            <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
            </para>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
            <seealso cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension.TenantId">
            <summary>
            Gets or sets the tenant ID.
            </summary>
            <value>
            An <see cref="T:System.Object"/> that uniquely identifies the tenant
            under which the current operation is executing.
            </value>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension.Attach(System.ServiceModel.OperationContext)">
            <summary>
            Enables an extension object to find out when it has been aggregated.
            </summary>
            <param name="owner">
            The extensible object that aggregates this extension.
            </param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension.Detach(System.ServiceModel.OperationContext)">
            <summary>
            Enables an object to find out when it is no longer aggregated.
            </summary>
            <param name="owner">
            The extensible object that aggregates this extension.
            </param>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1">
             <summary>
             Behavior for WCF clients and service hosts that is used to propagate
             tenant ID from client to service.
             </summary>
             <typeparam name="TTenantId">
             The type of the tenant ID to propagate. Must be nullable and
             serializable so it can be added to a message header.
             </typeparam>
             <remarks>
             <para>
             This behavior applies the <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1"/>
             to WCF clients and service hosts to automatically get the tenant ID on
             the WCF client end, add the ID to a header on the outbound message, and
             have the tenant ID read from headers on the service side and added to the
             operation context in an
             <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>.
             This allows you, on the service side, to use the
             <see cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
             as your registered <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>.
             </para>
             </remarks>
             <example>
             <para>
             In the following examples, the tenant ID is a <see cref="T:System.String"/>,
             so the <typeparamref name="TTenantId"/> in the examples corresponds.
             In your application, your tenant ID may be a nullable GUID or some other
             object, so you'd need to update accordingly. That would mean passing
             a different type as <typeparamref name="TTenantId"/> and implementing
             a custom <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>
             that parses the appropriate tenant ID from the execution context.
             </para>
             <para>
             The following snippet shows what registration of this behavior
             might look like in an ASP.NET application that consumes WCF services.
             </para>
             <code lang="C#">
             public class MvcApplication : HttpApplication, IContainerProviderAccessor
             {
               private static IContainerProvider _containerProvider;
            
               public IContainerProvider ContainerProvider
               {
                 get { return _containerProvider; }
               }
            
               public static void RegisterRoutes(RouteCollection routes)
               {
                 // Register your routes as normal.
               }
            
               protected void Application_Start()
               {
                 // Create a tenant ID strategy that will get the tenant from
                 // your ASP.NET request context.
                 var tenantIdStrategy = new RequestParameterTenantIdentificationStrategy("tenant");
            
                 // Register application-level dependencies and controllers.
                 var builder = new ContainerBuilder();
                 builder.RegisterType&lt;HomeController&gt;();
                 // ... and so on.
            
                 // When you register the WCF service client, add the
                 // TenantPropagationBehavior to the Opening event:
            
                 builder.Register(
                   c =&gt; new ChannelFactory&lt;IMultitenantService&gt;(
                     new BasicHttpBinding(),
                     new EndpointAddress("http://server/TheService.svc"))).SingleInstance();
                 builder.Register(
                   c =&gt;
                   {
                     var factory = c.Resolve&lt;ChannelFactory&lt;IMultitenantService&gt;&gt;();
                     factory.Opening +=
                       (sender, args) =&gt;
                         factory.Endpoint.Behaviors.Add(
                         new TenantPropagationBehavior&lt;string&gt;(tenantIdStrategy);
                     return factory.CreateChannel()
                   }).InstancePerHttpRequest();
            
                 // Create the multitenant container.
                 var mtc = new MultitenantContainer(tenantIdStrategy, builder.Build());
            
                 // Register tenant specific overrides and set up the
                 // application container provider.
                 _containerProvider = new ContainerProvider(mtc);
            
                 // Do other MVC setup like route registration, etc.
                 ControllerBuilder.Current.SetControllerFactory(new AutofacControllerFactory(this.ContainerProvider));
                 AreaRegistration.RegisterAllAreas();
                 RegisterRoutes(RouteTable.Routes);
               }
             }
             </code>
             <para>
             Note that much of the above code is the standard ASP.NET application
             wireup with Autofac. The important part is when you register the service
             client - it needs to have a <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
             attached to it that can get the container provider from the
             current application.
             </para>
             <para>
             The following snippet shows what registration of this behavior
             looks like in a WCF application hosted in IIS:
             </para>
             <code lang="C#">
             public class Global : System.Web.HttpApplication
             {
               protected void Application_Start(object sender, EventArgs e)
               {
                   // Create the tenant ID strategy. Required for multitenant integration.
                   var tenantIdStrategy = new OperationContextTenantIdentificationStrategy();
            
                   // Register application-level dependencies and service implementations.
                   var builder = new ContainerBuilder();
                   builder.RegisterType&lt;BaseImplementation&gt;().As&lt;IMultitenantService&gt;();
                   // ... and so on.
            
                   // Create the multitenant container.
                   var mtc = new MultitenantContainer(tenantIdStrategy, builder.Build());
            
                   // Configure tenant-specific overrides and set the WCF host container.
                   Autofac.Multitenant.Wcf.AutofacHostFactory.Container = mtc;
            
                   // Add a behavior to service hosts that get created so incoming messages
                   // get inspected and the tenant ID can be parsed from message headers.
                   Autofac.Multitenant.Wcf.AutofacHostFactory.HostConfigurationAction =
                     host =&gt;
                       host.Opening += (s, args) =&gt;
                         host.Description.Behaviors.Add(new TenantPropagationBehavior&lt;string&gt;(tenantIdStrategy));
               }
             }
             </code>
             <para>
             Note that it is also very similar to standard wireup with Autofac WCF
             integration, just that you use the multitenant WCF host, a multitenant
             container, and a behavior to get the tenant ID from the operation context.
             </para>
             </example>
             <seealso cref="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1"/>
             <seealso cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.TenantIdentificationStrategy">
            <summary>
            Gets the strategy used for identifying the current tenant.
            </summary>
            <value>
            An <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>
            used to identify the current tenant from the execution context.
            </value>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.#ctor(Autofac.Multitenant.ITenantIdentificationStrategy)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/> class.
            </summary>
            <param name="tenantIdentificationStrategy">
            The strategy to use for identifying the current tenant.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="tenantIdentificationStrategy" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.AddBindingParameters(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Channels.BindingParameterCollection)">
            <summary>
            Implement to pass data at runtime to bindings to support custom behavior.
            </summary>
            <param name="endpoint">The endpoint to modify.</param>
            <param name="bindingParameters">
            The objects that binding elements require to support the behavior.
            </param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)">
            <summary>
            Provides the ability to pass custom data to binding elements to support the contract implementation.
            </summary>
            <param name="serviceDescription">The service description of the service.</param>
            <param name="serviceHostBase">The host of the service.</param>
            <param name="endpoints">The service endpoints.</param>
            <param name="bindingParameters">
            Custom objects to which binding elements have access.
            </param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.ApplyClientBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.ClientRuntime)">
            <summary>
            Adds the <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1"/>
            to the client.
            </summary>
            <param name="endpoint">The endpoint that is to be customized.</param>
            <param name="clientRuntime">The client runtime to be customized.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="clientRuntime" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)">
            <summary>
            Adds the <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1"/>
            to the service endpoints.
            </summary>
            <param name="serviceDescription">The service description.</param>
            <param name="serviceHostBase">The host that is currently being built.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="serviceHostBase" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.EndpointDispatcher)">
            <summary>
            Implements a modification or extension of the service across an endpoint.
            </summary>
            <param name="endpoint">The endpoint that exposes the contract.</param>
            <param name="endpointDispatcher">The endpoint dispatcher to be modified or extended.</param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.Validate(System.ServiceModel.Description.ServiceEndpoint)">
            <summary>
            Implement to confirm that the endpoint meets some intended criteria.
            </summary>
            <param name="endpoint">The endpoint to validate.</param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)">
            <summary>
            Provides the ability to inspect the service host and the service description to confirm that the service can run successfully.
            </summary>
            <param name="serviceDescription">The service description.</param>
            <param name="serviceHostBase">The service host that is currently being constructed.</param>
        </member>
        <member name="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1">
            <summary>
            Message inspector that helps in passing the tenant ID from a WCF client
            to the respective service.
            </summary>
            <typeparam name="TTenantId">
            The type of the tenant ID to propagate. Must be nullable and
            serializable so it can be added to a message header.
            </typeparam>
            <remarks>
            <para>
            Use this in conjunction with the <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
            to automatically get the tenant ID on the WCF client end, add the ID
            to a header on the outbound message, and have the tenant ID read from
            headers on the service side and added to the operation context in an
            <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>.
            This allows you, on the service side, to use the
            <see cref="T:Autofac.Multitenant.Wcf.OperationContextTenantIdentificationStrategy"/>
            as your registered <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>.
            </para>
            <para>
            For a usage example, see <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>.
            </para>
            </remarks>
            <seealso cref="T:Autofac.Multitenant.Wcf.TenantPropagationBehavior`1"/>
        </member>
        <member name="F:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.TenantHeaderNamespace">
            <summary>
            Namespace of the header that gets added to messages and carries tenant information.
            </summary>
        </member>
        <member name="F:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.TenantHeaderName">
            <summary>
            Name of the header that gets added to messages and carries the tenant ID.
            </summary>
        </member>
        <member name="P:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.TenantIdentificationStrategy">
            <summary>
            Gets the strategy used for identifying the current tenant.
            </summary>
            <value>
            An <see cref="T:Autofac.Multitenant.ITenantIdentificationStrategy"/>
            used to identify the current tenant from the execution context.
            </value>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.#ctor(Autofac.Multitenant.ITenantIdentificationStrategy)">
            <summary>
            Initializes a new instance of the
            <see cref="T:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1"/> class.
            </summary>
            <param name="tenantIdentificationStrategy">
            The strategy to use for identifying the current tenant.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="tenantIdentificationStrategy" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.AfterReceiveReply(System.ServiceModel.Channels.Message@,System.Object)">
            <summary>
            Enables inspection or modification of a message after a reply message
            is received but prior to passing it back to the client application.
            </summary>
            <param name="reply">
            The message to be transformed into types and handed back to the client
            application.
            </param>
            <param name="correlationState">
            Correlation state data.
            </param>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.AfterReceiveRequest(System.ServiceModel.Channels.Message@,System.ServiceModel.IClientChannel,System.ServiceModel.InstanceContext)">
            <summary>
            Inspects inbound message headers and adds an
            <see cref="T:Autofac.Multitenant.Wcf.TenantIdentificationContextExtension"/>
            to the current operation context with the tenant ID.
            </summary>
            <param name="request">The request message.</param>
            <param name="channel">The incoming channel.</param>
            <param name="instanceContext">The current service instance.</param>
            <returns>
            Always returns <see langword="null" />. There is no correlation state
            value to be managed in this inspector.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="request" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.BeforeSendRequest(System.ServiceModel.Channels.Message@,System.ServiceModel.IClientChannel)">
            <summary>
            Adds the tenant ID to the outbound message headers.
            </summary>
            <param name="request">The message to be sent to the service.</param>
            <param name="channel">The client object channel.</param>
            <returns>
            Always returns <see langword="null" />. There is no correlation state
            value to be managed in this inspector.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="request" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Autofac.Multitenant.Wcf.TenantPropagationMessageInspector`1.BeforeSendReply(System.ServiceModel.Channels.Message@,System.Object)">
            <summary>
            Called after the operation has returned but before the reply message
            is sent.
            </summary>
            <param name="reply">
            The reply message. This value is <see langword="null" /> if the
            operation is one way.
            </param>
            <param name="correlationState">
            The correlation object returned from the
            <see cref="M:System.ServiceModel.Dispatcher.IDispatchMessageInspector.AfterReceiveRequest(System.ServiceModel.Channels.Message@,System.ServiceModel.IClientChannel,System.ServiceModel.InstanceContext)"/>
            method.
            </param>
        </member>
    </members>
</doc>
